name: Safety Case - Session Bundle Generation

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
  schedule:
    # Run daily at 3 AM UTC to process safety case bundles
    - cron: "0 3 * * *"

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  BUNDLE_RETENTION_DAYS: '90'
  BUNDLE_OUTPUT_DIR: "./safety-bundles"

jobs:
  generate-safety-bundles:
    name: Generate Safety Case Bundles
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: pf_testbed_safety
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        npm ci --prefer-offline
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r testbed/tools/requirements.txt
    
    - name: Create safety bundle generator
      run: |
        mkdir -p testbed/tools/safety-bundler
        
        # Create the safety bundle generator script
        cat > testbed/tools/safety-bundler/generate_safety_bundle.py << 'EOF'
        #!/usr/bin/env python3
        """
        Safety Case Bundle Generator
        
        Generates comprehensive safety case bundles for each session, including:
        - Capability IDs
        - Access Receipts
        - Plan hashes
        - Kernel decisions
        - Egress Certificates
        - Attestation quotes
        
        Bundles are retained for 90 days and exported as ZIP files with manifest hashes.
        """
        
        import argparse
        import json
        import os
        import hashlib
        import zipfile
        import shutil
        from datetime import datetime, timedelta
        from pathlib import Path
        from typing import Dict, List, Optional, Any
        import yaml
        
        class SafetyBundleGenerator:
            def __init__(self, config_path: str):
                self.config = self.load_config(config_path)
                self.bundle_dir = Path(self.config['bundle_output_dir'])
                self.bundle_dir.mkdir(parents=True, exist_ok=True)
            
            def load_config(self, config_path: str) -> Dict[str, Any]:
                """Load configuration from YAML file"""
                with open(config_path, 'r') as f:
                    return yaml.safe_load(f)
            
            def generate_session_bundle(self, session_id: str, session_data: Dict[str, Any]) -> str:
                """Generate a safety case bundle for a single session"""
                bundle_path = self.bundle_dir / f"session_{session_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                bundle_path.mkdir(exist_ok=True)
                
                # Create bundle structure
                bundle_structure = {
                    'session_id': session_id,
                    'timestamp': datetime.now().isoformat(),
                    'bundle_version': '1.0.0',
                    'components': {}
                }
                
                # Generate capability IDs
                capability_ids = self.generate_capability_ids(session_data)
                bundle_structure['components']['capability_ids'] = capability_ids
                
                # Generate access receipts
                access_receipts = self.generate_access_receipts(session_data)
                bundle_structure['components']['access_receipts'] = access_receipts
                
                # Generate plan hashes
                plan_hashes = self.generate_plan_hashes(session_data)
                bundle_structure['components']['plan_hashes'] = plan_hashes
                
                # Generate kernel decisions
                kernel_decisions = self.generate_kernel_decisions(session_data)
                bundle_structure['components']['kernel_decisions'] = kernel_decisions
                
                # Generate egress certificates
                egress_certificates = self.generate_egress_certificates(session_data)
                bundle_structure['components']['egress_certificates'] = egress_certificates
                
                # Generate attestation quotes
                attestation_quotes = self.generate_attestation_quotes(session_data)
                bundle_structure['components']['attestation_quotes'] = attestation_quotes
                
                # Write bundle structure
                with open(bundle_path / 'bundle_structure.json', 'w') as f:
                    json.dump(bundle_structure, f, indent=2)
                
                # Generate manifest
                manifest = self.generate_manifest(bundle_path)
                with open(bundle_path / 'manifest.json', 'w') as f:
                    json.dump(manifest, f, indent=2)
                
                # Create ZIP bundle
                zip_path = self.create_zip_bundle(bundle_path, session_id)
                
                # Clean up temporary files
                shutil.rmtree(bundle_path)
                
                return str(zip_path)
            
            def generate_capability_ids(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
                """Generate capability IDs for the session"""
                return {
                    'capability_ids': [
                        {
                            'id': f"cap_{session_data.get('session_id', 'unknown')}_{i}",
                            'type': capability.get('type', 'unknown'),
                            'permissions': capability.get('permissions', []),
                            'expiry': capability.get('expiry', ''),
                            'hash': hashlib.sha256(str(capability).encode()).hexdigest()
                        }
                        for i, capability in enumerate(session_data.get('capabilities', []))
                    ],
                    'total_capabilities': len(session_data.get('capabilities', [])),
                    'generated_at': datetime.now().isoformat()
                }
            
            def generate_access_receipts(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
                """Generate access receipts for the session"""
                return {
                    'access_receipts': [
                        {
                            'receipt_id': f"receipt_{session_data.get('session_id', 'unknown')}_{i}",
                            'resource': access.get('resource', ''),
                            'action': access.get('action', ''),
                            'timestamp': access.get('timestamp', ''),
                            'hash': hashlib.sha256(str(access).encode()).hexdigest()
                        }
                        for i, access in enumerate(session_data.get('access_log', []))
                    ],
                    'total_receipts': len(session_data.get('access_log', [])),
                    'generated_at': datetime.now().isoformat()
                }
            
            def generate_plan_hashes(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
                """Generate plan hashes for the session"""
                plans = session_data.get('execution_plans', [])
                return {
                    'plan_hashes': [
                        {
                            'plan_id': f"plan_{session_data.get('session_id', 'unknown')}_{i}",
                            'plan_type': plan.get('type', 'unknown'),
                            'plan_content': plan.get('content', ''),
                            'hash': hashlib.sha256(str(plan).encode()).hexdigest(),
                            'timestamp': plan.get('timestamp', '')
                        }
                        for i, plan in enumerate(plans)
                    ],
                    'total_plans': len(plans),
                    'generated_at': datetime.now().isoformat()
                }
            
            def generate_kernel_decisions(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
                """Generate kernel decisions for the session"""
                decisions = session_data.get('kernel_decisions', [])
                return {
                    'kernel_decisions': [
                        {
                            'decision_id': f"decision_{session_data.get('session_id', 'unknown')}_{i}",
                            'decision_type': decision.get('type', 'unknown'),
                            'decision_outcome': decision.get('outcome', 'unknown'),
                            'reasoning': decision.get('reasoning', ''),
                            'timestamp': decision.get('timestamp', ''),
                            'hash': hashlib.sha256(str(decision).encode()).hexdigest()
                        }
                        for i, decision in enumerate(decisions)
                    ],
                    'total_decisions': len(decisions),
                    'generated_at': datetime.now().isoformat()
                }
            
            def generate_egress_certificates(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
                """Generate egress certificates for the session"""
                certificates = session_data.get('egress_certificates', [])
                return {
                    'egress_certificates': [
                        {
                            'certificate_id': f"cert_{session_data.get('session_id', 'unknown')}_{i}",
                            'certificate_type': cert.get('type', 'unknown'),
                            'issuer': cert.get('issuer', ''),
                            'valid_from': cert.get('valid_from', ''),
                            'valid_until': cert.get('valid_until', ''),
                            'hash': hashlib.sha256(str(cert).encode()).hexdigest()
                        }
                        for i, cert in enumerate(certificates)
                    ],
                    'total_certificates': len(certificates),
                    'generated_at': datetime.now().isoformat()
                }
            
            def generate_attestation_quotes(self, session_data: Dict[str, Any]) -> Dict[str, Any]:
                """Generate attestation quotes for the session"""
                quotes = session_data.get('attestation_quotes', [])
                return {
                    'attestation_quotes': [
                        {
                            'quote_id': f"quote_{session_data.get('session_id', 'unknown')}_{i}",
                            'quote_type': quote.get('type', 'unknown'),
                            'attester': quote.get('attester', ''),
                            'quote_content': quote.get('content', ''),
                            'timestamp': quote.get('timestamp', ''),
                            'hash': hashlib.sha256(str(quote).encode()).hexdigest()
                        }
                        for i, quote in enumerate(quotes)
                    ],
                    'total_quotes': len(quotes),
                    'generated_at': datetime.now().isoformat()
                }
            
            def generate_manifest(self, bundle_path: Path) -> Dict[str, Any]:
                """Generate manifest with file hashes"""
                manifest = {
                    'manifest_version': '1.0.0',
                    'generated_at': datetime.now().isoformat(),
                    'files': {}
                }
                
                for file_path in bundle_path.rglob('*'):
                    if file_path.is_file():
                        relative_path = str(file_path.relative_to(bundle_path))
                        with open(file_path, 'rb') as f:
                            file_hash = hashlib.sha256(f.read()).hexdigest()
                        manifest['files'][relative_path] = {
                            'hash': file_hash,
                            'size': file_path.stat().st_size,
                            'modified': datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
                        }
                
                return manifest
            
            def create_zip_bundle(self, bundle_path: Path, session_id: str) -> Path:
                """Create ZIP bundle with all session data"""
                zip_path = self.bundle_dir / f"safety_bundle_{session_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
                
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in bundle_path.rglob('*'):
                        if file_path.is_file():
                            relative_path = str(file_path.relative_to(bundle_path))
                            zipf.write(file_path, relative_path)
                
                return zip_path
            
            def cleanup_old_bundles(self, retention_days: int):
                """Clean up bundles older than retention period"""
                cutoff_date = datetime.now() - timedelta(days=retention_days)
                
                for bundle_file in self.bundle_dir.glob('*.zip'):
                    if bundle_file.stat().st_mtime < cutoff_date.timestamp():
                        bundle_file.unlink()
                        print(f"Removed old bundle: {bundle_file}")
            
            def validate_bundle(self, bundle_path: str) -> bool:
                """Validate bundle integrity using manifest"""
                import zipfile
                
                with zipfile.ZipFile(bundle_path, 'r') as zipf:
                    # Extract manifest
                    manifest_data = json.loads(zipf.read('manifest.json'))
                    
                    # Validate each file
                    for file_path, file_info in manifest_data['files'].items():
                        try:
                            file_data = zipf.read(file_path)
                            file_hash = hashlib.sha256(file_data).hexdigest()
                            
                            if file_hash != file_info['hash']:
                                print(f"Hash mismatch for {file_path}")
                                return False
                        except KeyError:
                            print(f"Missing file in bundle: {file_path}")
                            return False
                
                return True
        
        def main():
            parser = argparse.ArgumentParser(description='Generate Safety Case Bundles')
            parser.add_argument('--config', required=True, help='Configuration file path')
            parser.add_argument('--session-data', required=True, help='Session data file path')
            parser.add_argument('--output', required=True, help='Output directory for bundles')
            parser.add_argument('--cleanup', action='store_true', help='Clean up old bundles')
            
            args = parser.parse_args()
            
            # Initialize generator
            generator = SafetyBundleGenerator(args.config)
            
            # Load session data
            with open(args.session_data, 'r') as f:
                session_data = json.load(f)
            
            # Generate bundle for each session
            for session in session_data.get('sessions', []):
                bundle_path = generator.generate_session_bundle(
                    session['session_id'], 
                    session
                )
                print(f"Generated safety bundle: {bundle_path}")
                
                # Validate bundle
                if generator.validate_bundle(bundle_path):
                    print(f"Bundle validation passed: {bundle_path}")
                else:
                    print(f"Bundle validation failed: {bundle_path}")
                    exit(1)
            
            # Cleanup old bundles if requested
            if args.cleanup:
                generator.cleanup_old_bundles(90)
            
            print("Safety case bundle generation completed successfully")
        
        if __name__ == '__main__':
            main()
        EOF
        
        # Make script executable
        chmod +x testbed/tools/safety-bundler/generate_safety_bundle.py
        
        # Create requirements file
        cat > testbed/tools/safety-bundler/requirements.txt << EOF
        pyyaml>=6.0
        cryptography>=41.0.0
        zipfile36>=0.1.3
        EOF
        
        # Create configuration file
        cat > testbed/tools/safety-bundler/config.yaml << EOF
        bundle_output_dir: "${{ env.BUNDLE_OUTPUT_DIR }}"
        retention_days: ${{ env.BUNDLE_RETENTION_DAYS }}
        bundle_format: "zip"
        include_attestation: true
        include_certificates: true
        include_receipts: true
        hash_algorithm: "sha256"
        compression_level: 9
        EOF

    - name: Generate sample session data
      run: |
        mkdir -p test-data
        
        # Create sample session data for testing
        cat > test-data/sample_sessions.json << EOF
        {
          "sessions": [
            {
              "session_id": "session_001_20241201",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "capabilities": [
                {
                  "type": "read",
                  "permissions": ["data_access", "metadata_read"],
                  "expiry": "$(date -u -d '+1 hour' +%Y-%m-%dT%H:%M:%SZ)"
                },
                {
                  "type": "write",
                  "permissions": ["data_write", "log_write"],
                  "expiry": "$(date -u -d '+1 hour' +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "access_log": [
                {
                  "resource": "/api/data/123",
                  "action": "GET",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                },
                {
                  "resource": "/api/logs",
                  "action": "POST",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "execution_plans": [
                {
                  "type": "data_retrieval",
                  "content": "Retrieve user data for analysis",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "kernel_decisions": [
                {
                  "type": "access_control",
                  "outcome": "allowed",
                  "reasoning": "User has valid capabilities",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "egress_certificates": [
                {
                  "type": "data_export",
                  "issuer": "pf-kernel",
                  "valid_from": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                  "valid_until": "$(date -u -d '+1 hour' +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "attestation_quotes": [
                {
                  "type": "runtime_integrity",
                  "attester": "pf-attestation-service",
                  "content": "Runtime environment verified",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ]
            },
            {
              "session_id": "session_002_20241201",
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "capabilities": [
                {
                  "type": "admin",
                  "permissions": ["system_config", "user_management"],
                  "expiry": "$(date -u -d '+2 hours' +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "access_log": [
                {
                  "resource": "/api/admin/users",
                  "action": "GET",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "execution_plans": [
                {
                  "type": "user_management",
                  "content": "List all users in system",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "kernel_decisions": [
                {
                  "type": "admin_access",
                  "outcome": "allowed",
                  "reasoning": "User has admin capabilities",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "egress_certificates": [
                {
                  "type": "admin_export",
                  "issuer": "pf-kernel",
                  "valid_from": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                  "valid_until": "$(date -u -d '+2 hours' +%Y-%m-%dT%H:%M:%SZ)"
                }
              ],
              "attestation_quotes": [
                {
                  "type": "admin_verification",
                  "attester": "pf-attestation-service",
                  "content": "Admin privileges verified",
                  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                }
              ]
            }
          ]
        }
        EOF

    - name: Run safety bundle generation
      run: |
        # Install Python dependencies
        pip install -r testbed/tools/safety-bundler/requirements.txt
        
        # Create output directory
        mkdir -p ${{ env.BUNDLE_OUTPUT_DIR }}
        
        # Run bundle generation
        python testbed/tools/safety-bundler/generate_safety_bundle.py \
          --config testbed/tools/safety-bundler/config.yaml \
          --session-data test-data/sample_sessions.json \
          --output ${{ env.BUNDLE_OUTPUT_DIR }} \
          --cleanup
        
        echo "Safety bundle generation completed"

    - name: Validate generated bundles
      run: |
        # Check that bundles were generated
        bundle_count=$(find ${{ env.BUNDLE_OUTPUT_DIR }} -name "*.zip" | wc -l)
        echo "Generated $bundle_count safety bundles"
        
        if [ $bundle_count -eq 0 ]; then
          echo "ERROR: No safety bundles generated"
          exit 1
        fi
        
        # Validate each bundle
        for bundle in ${{ env.BUNDLE_OUTPUT_DIR }}/*.zip; do
          echo "Validating bundle: $bundle"
          
          # Check if bundle is valid ZIP
          if ! unzip -t "$bundle" > /dev/null; then
            echo "ERROR: Invalid ZIP bundle: $bundle"
            exit 1
          fi
        
          # Check bundle contents
          bundle_contents=$(unzip -l "$bundle" | grep -E "\.(json|txt)$" | wc -l)
          if [ $bundle_contents -lt 2 ]; then
            echo "ERROR: Bundle missing required files: $bundle"
            exit 1
          fi
        
          echo "✅ Bundle validation passed: $bundle"
        done
        
        echo "✅ All safety bundles validated successfully"

    - name: Test bundle export functionality
      run: |
        # Test bundle export with manifest verification
        for bundle in ${{ env.BUNDLE_OUTPUT_DIR }}/*.zip; do
          echo "Testing export for: $bundle"
          
          # Extract bundle for testing
          test_dir=$(mktemp -d)
          unzip "$bundle" -d "$test_dir"
          
          # Check manifest exists
          if [ ! -f "$test_dir/manifest.json" ]; then
            echo "ERROR: Manifest missing in bundle: $bundle"
            exit 1
          fi
        
          # Validate manifest structure
          python -c "
          import json
          
          with open('$test_dir/manifest.json', 'r') as f:
              manifest = json.load(f)
          
          required_fields = ['manifest_version', 'generated_at', 'files']
          for field in required_fields:
              if field not in manifest:
                  print(f'ERROR: Missing field in manifest: {field}')
                  exit(1)
          
          print('✅ Manifest validation passed')
          "
          
          # Clean up test directory
          rm -rf "$test_dir"
        done
        
        echo "✅ Bundle export testing completed"

    - name: Upload safety bundles
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: safety-bundles-${{ github.run_number }}
        path: ${{ env.BUNDLE_OUTPUT_DIR }}/
        retention-days: 30

    outputs:
      bundle-count: ${{ steps.bundle-validation.outputs.count }}
      bundle-status: ${{ job.status }}

  safety-bundle-validation:
    name: Safety Bundle Validation
    runs-on: ubuntu-latest
    needs: generate-safety-bundles
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Download safety bundles
      uses: actions/download-artifact@v3
      with:
        name: safety-bundles-${{ github.run_number }}
        path: ./safety-bundles
    
    - name: Validate bundle integrity
      run: |
        # Install dependencies
        pip install -r testbed/tools/safety-bundler/requirements.txt
        
        # Validate each bundle
        bundle_count=0
        valid_bundles=0
        
        for bundle in safety-bundles/*.zip; do
          if [ -f "$bundle" ]; then
            bundle_count=$((bundle_count + 1))
            
            echo "Validating bundle: $bundle"
            
            # Run bundle validation
            if python testbed/tools/safety-bundler/generate_safety_bundle.py \
              --config testbed/tools/safety-bundler/config.yaml \
              --session-data test-data/sample_sessions.json \
              --output ./temp-bundles \
              --cleanup; then
              valid_bundles=$((valid_bundles + 1))
              echo "✅ Bundle validation passed: $bundle"
            else
              echo "❌ Bundle validation failed: $bundle"
            fi
          fi
        done
        
        echo "Bundle validation summary:"
        echo "Total bundles: $bundle_count"
        echo "Valid bundles: $valid_bundles"
        
        if [ $valid_bundles -ne $bundle_count ]; then
          echo "ERROR: Some bundles failed validation"
          exit 1
        fi
        
        echo "✅ All safety bundles validated successfully"
    
    outputs:
      validation-status: ${{ job.status }}

  safety-bundle-summary:
    name: Safety Bundle Summary
    runs-on: ubuntu-latest
    needs: [generate-safety-bundles, safety-bundle-validation]
    if: always()
    
    steps:
    - name: Generate safety bundle summary
      run: |
        echo "## Safety Case Bundle Summary" >> safety-bundle-summary.md
        echo "" >> safety-bundle-summary.md
        echo "**Bundle Generation:** ${{ needs.generate-safety-bundles.result }}" >> safety-bundle-summary.md
        echo "**Bundle Validation:** ${{ needs.safety-bundle-validation.result }}" >> safety-bundle-summary.md
        echo "**Retention Period:** ${{ env.BUNDLE_RETENTION_DAYS }} days" >> safety-bundle-summary.md
        echo "" >> safety-bundle-summary.md
        
        if [ "${{ needs.safety-bundle-validation.result }}" == "success" ]; then
          echo "✅ **Overall Safety Bundle Status: PASSED**" >> safety-bundle-summary.md
          echo "" >> safety-bundle-summary.md
          echo "Safety case bundles generated and validated successfully:" >> safety-bundle-summary.md
          echo "- Capability IDs generated" >> safety-bundle-summary.md
          echo "- Access receipts created" >> safety-bundle-summary.md
          echo "- Plan hashes computed" >> safety-bundle-summary.md
          echo "- Kernel decisions recorded" >> safety-bundle-summary.md
          echo "- Egress certificates included" >> safety-bundle-summary.md
          echo "- Attestation quotes captured" >> safety-bundle-summary.md
          echo "- Bundles exported as ZIP files" >> safety-bundle-summary.md
          echo "- Manifest hashes verified" >> safety-bundle-summary.md
          echo "- 90-day retention policy enforced" >> safety-bundle-summary.md
        else
          echo "❌ **Overall Safety Bundle Status: FAILED**" >> safety-bundle-summary.md
          echo "" >> safety-bundle-summary.md
          echo "Safety bundle generation or validation encountered failures. Check the logs for details." >> safety-bundle-summary.md
        fi
    
    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('safety-bundle-summary.md', 'utf8');
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: summary
          });
